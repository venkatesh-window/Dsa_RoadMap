<!DOCTYPE html>
<html>
<head>
<title>Stack and Queues Tutorial</title>
</head>
<body>
<h1>Stack and Queues: Complete Guide</h1>

<h2>1. Stack Fundamentals</h2>
<h3>What is a Stack?</h3>
<p>A Stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle. Elements are added and removed from the same end called the "top".</p>

<h3>Basic Stack Operations:</h3>
<ul>
<li><strong>Push</strong>: Add an element to the top of the stack</li>
<li><strong>Pop</strong>: Remove and return the top element from the stack</li>
<li><strong>Peek/Top</strong>: View the top element without removing it</li>
<li><strong>isEmpty</strong>: Check if stack is empty</li>
<li><strong>isFull</strong>: Check if stack is full (in fixed-size implementations)</li>
</ul>

<h3>Stack Implementation Methods:</h3>
<ul>
<li><strong>Array-based Implementation</strong>: Fixed size, uses array</li>
<li><strong>Linked List-based Implementation</strong>: Dynamic size, uses nodes</li>
</ul>

<h2>2. Queue Fundamentals</h2>
<h3>What is a Queue?</h3>
<p>A Queue is a linear data structure that follows the FIFO (First-In-First-Out) principle. Elements are added at the rear and removed from the front.</p>

<h3>Basic Queue Operations:</h3>
<ul>
<li><strong>Enqueue</strong>: Add an element to the rear of the queue</li>
<li><strong>Dequeue</strong>: Remove and return the front element from the queue</li>
<li><strong>Front</strong>: View the front element without removing it</li>
<li><strong>Rear</strong>: View the rear element without removing it</li>
<li><strong>isEmpty</strong>: Check if queue is empty</li>
</ul>

<h3>Queue Types:</h3>
<ul>
<li><strong>Simple Queue</strong>: Basic FIFO structure</li>
<li><strong>Circular Queue</strong>: Last element points to first element</li>
<li><strong>Priority Queue</strong>: Elements with priority</li>
<li><strong>Double Ended Queue (Deque)</strong>: Insert/delete from both ends</li>
</ul>

<h2>3. Prefix, Infix, and Postfix Expressions</h2>

<h3>Infix Notation</h3>
<p>Operators are written between operands. Example: A + B</p>
<p>This is the common mathematical notation but requires parentheses and precedence rules.</p>

<h3>Prefix Notation (Polish Notation)</h3>
<p>Operators are written before their operands. Example: + A B</p>
<p><strong>Evaluation Steps:</strong></p>
<ol>
<li>Scan expression from right to left</li>
<li>When operator is encountered, apply it to next two operands</li>
<li>Replace operator and operands with result</li>
<li>Continue until complete expression is evaluated</li>
</ol>

<h3>Postfix Notation (Reverse Polish Notation)</h3>
<p>Operators are written after their operands. Example: A B +</p>
<p><strong>Evaluation Steps:</strong></p>
<ol>
<li>Scan expression from left to right</li>
<li>When operand is found, push to stack</li>
<li>When operator is found, pop two operands, apply operator, push result back</li>
<li>Final result is the only element in stack</li>
</ol>

<h3>Conversion Rules:</h3>
<ul>
<li><strong>Infix to Postfix</strong>: Use stack to handle operator precedence</li>
<li><strong>Infix to Prefix</strong>: Reverse expression, convert to postfix, reverse result</li>
<li><strong>Postfix to Infix</strong>: Use stack to build expression</li>
<li><strong>Prefix to Infix</strong>: Similar to postfix but scan from right</li>
</ul>

<h2>4. Monotonic Stack</h2>

<h3>What is a Monotonic Stack?</h3>
<p>A stack that maintains either strictly increasing or strictly decreasing order of elements.</p>

<h3>Types of Monotonic Stacks:</h3>
<ul>
<li><strong>Monotonically Increasing Stack</strong>: Elements increase from bottom to top</li>
<li><strong>Monotonically Decreasing Stack</strong>: Elements decrease from bottom to top</li>
</ul>

<h3>When to Use Monotonic Stack:</h3>
<ul>
<li>Finding next greater/smaller element</li>
<li>Largest rectangle in histogram problems</li>
<li>Stock span problems</li>
<li>Trapping rainwater problems</li>
</ul>

<h3>Monotonic Stack Algorithm Pattern:</h3>
<pre>
for each element in array:
    while stack not empty and stack.top() violates monotonic condition:
        process and pop from stack
    push current element to stack
</pre>

<h2>5. Implementation Examples</h2>

<h3>Stack Implementation (Array-based):</h3>
<pre>
class Stack:
    def _init_(self, size):
        self.size = size
        self.stack = [None] * size
        self.top = -1
    
    def push(self, item):
        if self.top == self.size - 1:
            raise Exception("Stack Overflow")
        self.top += 1
        self.stack[self.top] = item
    
    def pop(self):
        if self.top == -1:
            raise Exception("Stack Underflow")
        item = self.stack[self.top]
        self.top -= 1
        return item
    
    def peek(self):
        if self.top == -1:
            return None
        return self.stack[self.top]
    
    def is_empty(self):
        return self.top == -1
</pre>

<h3>Queue Implementation (Array-based):</h3>
<pre>
class Queue:
    def _init_(self, size):
        self.size = size
        self.queue = [None] * size
        self.front = 0
        self.rear = -1
        self.count = 0
    
    def enqueue(self, item):
        if self.count == self.size:
            raise Exception("Queue Overflow")
        self.rear = (self.rear + 1) % self.size
        self.queue[self.rear] = item
        self.count += 1
    
    def dequeue(self):
        if self.count == 0:
            raise Exception("Queue Underflow")
        item = self.queue[self.front]
        self.front = (self.front + 1) % self.size
        self.count -= 1
        return item
    
    def is_empty(self):
        return self.count == 0
</pre>

<h2>6. LeetCode Practice Problems</h2>

<h3>Basic Stack Problems:</h3>
<ul>
<li><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></li>
<li><a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a></li>
<li><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></li>
<li><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></li>
</ul>

<h3>Expression Evaluation Problems:</h3>
<ul>
<li><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></li>
<li><a href="https://leetcode.com/problems/basic-calculator/">224. Basic Calculator</a></li>
<li><a href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II</a></li>
</ul>

<h3>Monotonic Stack Problems:</h3>
<ul>
<li><a href="https://leetcode.com/problems/next-greater-element-i/">496. Next Greater Element I</a></li>
<li><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a></li>
<li><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a></li>
<li><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a></li>
<li><a href="https://leetcode.com/problems/remove-k-digits/">402. Remove K Digits</a></li>
</ul>

<h3>Queue Problems:</h3>
<ul>
<li><a href="https://leetcode.com/problems/number-of-recent-calls/">933. Number of Recent Calls</a></li>
<li><a href="https://leetcode.com/problems/design-circular-queue/">622. Design Circular Queue</a></li>
<li><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></li>
</ul>

<h2>7. Common Interview Patterns</h2>

<h3>Stack Patterns:</h3>
<ul>
<li><strong>Parentheses Validation</strong>: Use stack to match opening and closing brackets</li>
<li><strong>Next Greater Element</strong>: Monotonic decreasing stack</li>
<li><strong>Next Smaller Element</strong>: Monotonic increasing stack</li>
<li><strong>Stock Span</strong>: Monotonic stack with indices</li>
<li><strong>Asteroid Collision</strong>: Stack simulation</li>
</ul>

<h3>Queue Patterns:</h3>
<ul>
<li><strong>BFS in Graphs/Trees</strong>: Queue for level order traversal</li>
<li><strong>Sliding Window</strong>: Deque for maximum/minimum in window</li>
<li><strong>Recent Counter</strong>: Queue for time-based operations</li>
<li><strong>Task Scheduling</strong>: Priority queue for scheduling</li>
</ul>

<h2>8. Time & Space Complexity</h2>

<h3>Stack Operations:</h3>
<ul>
<li>Push: O(1) time</li>
<li>Pop: O(1) time</li>
<li>Peek: O(1) time</li>
<li>Search: O(n) time</li>
<li>Space: O(n) for n elements</li>
</ul>

<h3>Queue Operations:</h3>
<ul>
<li>Enqueue: O(1) time</li>
<li>Dequeue: O(1) time</li>
<li>Front: O(1) time</li>
<li>Search: O(n) time</li>
<li>Space: O(n) for n elements</li>
</ul>

<h2>9. Key Points to Remember</h2>
<ul>
<li>Stacks are LIFO, Queues are FIFO</li>
<li>Monotonic stacks help solve "next greater/smaller element" problems efficiently</li>
<li>Postfix notation doesn't need parentheses and is easier to evaluate</li>
<li>Always check for stack/queue underflow/overflow conditions</li>
<li>Circular queues solve the memory wastage problem in array implementation</li>
<li>Deques can function as both stacks and queues</li>
</ul>

</body>
</html>