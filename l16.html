<!DOCTYPE html>
<html>
<head>
<title>Dynamic Programming Guide</title>
</head>
<body>
<h1>Dynamic Programming [Patterns and Problems]</h1>
<h2>What is Dynamic Programming (DP)?</h2>
<p>Dynamic Programming is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems. The main idea is to solve each subproblem only once and store its result, so you don't have to re-compute it when you need it later. This technique is called Memoization.</p>
<p>For a problem to be solvable with DP, it must have two key properties:</p>
<ul>
<li><strong>Overlapping Subproblems:</strong> A problem has overlapping subproblems if it can be broken down into smaller subproblems that are reused multiple times. For example, calculating the 5th Fibonacci number involves calculating the 4th and 3rd, and calculating the 4th involves calculating the 3rd and 2nd. The 3rd Fibonacci number is computed twice.</li>
<li><strong>Optimal Substructure:</strong> A problem has an optimal substructure if an optimal solution to the problem can be constructed from the optimal solutions of its subproblems.</li>
</ul>
<h2>Approaches to Dynamic Programming</h2>
<h3>1. Top-Down (Memoization)</h3>
<p>This is a recursive approach. You write a recursive function to solve the problem and cache the results of the subproblems in a lookup table (e.g., an array or hash map). Before computing a subproblem, you check if the result is already in the cache. If it is, you return it; otherwise, you compute it, store it, and then return it.</p>
<h3>2. Bottom-Up (Tabulation)</h3>
<p>This is an iterative approach. You solve the problem by starting from the smallest possible subproblem and building your way up to the desired solution. You typically use an array or a matrix (the "table") to store the results of the subproblems, filling it out in a specific order.</p>
<h2>Common DP Patterns and Problems</h2>
<h3>1. Fibonacci Style / 1D DP</h3>
<p>This is the simplest pattern. The solution for the current state dp[i] depends on the solutions of one or more preceding states, like dp[i-1] or dp[i-2]. Problems often involve counting ways or finding the max/min value up to a certain point in a sequence.</p>
<ul>
<li><a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a> (LeetCode 70)</li>
<li><a href="https://leetcode.com/problems/house-robber/">House Robber</a> (LeetCode 198)</li>
<li><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">Min Cost Climbing Stairs</a> (LeetCode 746)</li>
<li><a href="https://leetcode.com/problems/decode-ways/">Decode Ways</a> (LeetCode 91)</li>
</ul>
<h3>2. 0/1 Knapsack</h3>
<p>This pattern involves making a decision for each item: either you take it or you don't. You cannot take a fraction of an item or take it multiple times. The state is often represented by dp[i][w], which means the maximum value you can get using the first i items with a weight capacity of w.</p>
<ul>
<li><a href="https://leetcode.com/problems/partition-equal-subset-sum/">Partition Equal Subset Sum</a> (LeetCode 416)</li>
<li><a href="https://leetcode.com/problems/target-sum/">Target Sum</a> (LeetCode 494)</li>
<li><a href="https://leetcode.com/problems/last-stone-weight-ii/">Last Stone Weight II</a> (LeetCode 1049)</li>
</ul>
<h3>3. Unbounded Knapsack</h3>
<p>Similar to the 0/1 Knapsack, but you can use each item any number of times. The recurrence relation is slightly different to account for the reuse of items. dp[w] might represent the max value for a capacity of w.</p>
<ul>
<li><a href="https://leetcode.com/problems/coin-change/">Coin Change</a> (LeetCode 322)</li>
<li><a href="https://leetcode.com/problems/combination-sum-iv/">Combination Sum IV</a> (LeetCode 377)</li>
<li><a href="https://leetcode.com/problems/coin-change-ii/">Coin Change 2</a> (LeetCode 518)</li>
</ul>
<h3>4. Longest Common Subsequence (LCS)</h3>
<p>This pattern is common in problems involving two strings or sequences. The state dp[i][j] usually represents the solution for the prefixes of the sequences of length i and j. It's often used to find similarities, differences, or alignments between two sequences.</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-common-subsequence/">Longest Common Subsequence</a> (LeetCode 1143)</li>
<li><a href="https://leetcode.com/problems/edit-distance/">Edit Distance</a> (LeetCode 72)</li>
<li><a href="https://leetcode.com/problems/distinct-subsequences/">Distinct Subsequences</a> (LeetCode 115)</li>
<li><a href="https://leetcode.com/problems/delete-operation-for-two-strings/">Delete Operation for Two Strings</a> (LeetCode 583)</li>
</ul>
<h3>5. Longest Increasing Subsequence (LIS)</h3>
<p>In this pattern, you are given a single sequence and need to find the longest subsequence that follows a certain property (e.g., increasing, non-decreasing). The state dp[i] typically represents the length of the LIS ending at index i.</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest Increasing Subsequence</a> (LeetCode 300)</li>
<li><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/">Number of Longest Increasing Subsequence</a> (LeetCode 673)</li>
<li><a href="https://leetcode.com/problems/maximum-sum-increasing-subsequence/">Maximum Sum Increasing Subsequence</a> (LeetCode - Problem not on LeetCode, but a classic variant)</li>
<li><a href="https://leetcode.com/problems/russian-doll-envelopes/">Russian Doll Envelopes</a> (LeetCode 354)</li>
</ul>
<h3>6. DP on Grids / Matrix DP</h3>
<p>These problems involve a 2D grid, and you need to find a path from a starting point to an ending point with some constraints or find the optimal value within the grid. The state dp[i][j] represents the solution for the cell at (i, j).</p>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a> (LeetCode 62)</li>
<li><a href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a> (LeetCode 63)</li>
<li><a href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a> (LeetCode 64)</li>
<li><a href="https://leetcode.com/problems/maximal-square/">Maximal Square</a> (LeetCode 221)</li>
</ul>
<h3>7. DP on Strings (Palindromes)</h3>
<p>A sub-pattern where the problem is related to finding palindromic substrings or subsequences. The state dp[i][j] often represents whether the substring s[i...j] is a palindrome or the length of the longest palindromic subsequence in s[i...j].</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a> (LeetCode 5)</li>
<li><a href="https://leetcode.com/problems/palindromic-substrings/">Palindromic Substrings</a> (LeetCode 647)</li>
<li><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">Longest Palindromic Subsequence</a> (LeetCode 516)</li>
</ul>
<h2>A Framework for Solving DP Problems</h2>
<ol>
<li><strong>Recognize the DP Pattern:</strong> Look for keywords like finding the minimum/maximum, counting ways, or checking feasibility over a sequence, grid, or set of choices. Does it have optimal substructure and overlapping subproblems?</li>
<li><strong>Define the State:</strong> Create a DP array or matrix. Clearly define what each state dp[i] or dp[i][j] represents. For example, dp[i] could be "the maximum profit up to day i".</li>
<li><strong>Formulate the Recurrence Relation:</strong> This is the core logic. Write an equation that relates the solution of a state to the solutions of its subproblems. For example, dp[i] = max(dp[i-1], dp[i-2] + value[i]).</li>
<li><strong>Identify the Base Cases:</strong> Determine the smallest subproblems whose solutions are already known. These are the initial values for your DP table. For example, dp[0] = 0 or dp[0] = array[0].</li>
<li><strong>Implement the Solution:</strong> Choose between a top-down (memoization) or bottom-up (tabulation) approach and write the code. Tabulation is often more efficient as it avoids recursion overhead.</li>
</ol>
</body>
</html>